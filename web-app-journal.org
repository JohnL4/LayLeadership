# -*- org -*-
#+TITLE: Being a Journal of my Java Web-App Development Journey
#+COLUMNS: %12TODO %10WHO %3PRIORITY(PRI) %3HOURS(HRS){est+} %85ITEM
# #+INFOJS_OPT: view:showall toc:t ltoc:nil path:../org-info.js mouse:#B3F2E3
# Pandoc needs H:9; default is H:3.
# `^:nil' means raw underscores and carets are not interpreted to mean sub- and superscript.  (Use {} to force interpretation.)
#+OPTIONS: author:nil creator:t H:9 ^:{}
#+HTML_HEAD: <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono:400,400i,600,600i|IBM+Plex+Sans:400,400i,600,600i|IBM+Plex+Serif:400,400i,600,600i">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode.css" />

# Generates "up" and "home" links ("." is "current directory").  Can comment one out.
#+HTML_LINK_UP: .
#+HTML_LINK_HOME: /index.html

# Use ``#+ATTR_HTML: :class lower-alpha'' on line before list to use the following class.
# See https://emacs.stackexchange.com/a/18943/17421
# 
#+HTML_HEAD: <style type="text/css">
#+HTML_HEAD:   /* BODY { background: black; color: white; } */
#+HTML_HEAD:   ol.lower-alpha { list-style-type: lower-alpha; }
#+HTML_HEAD:   .open-question { background: rgba( 255, 0, 255, 0.3); }
#+HTML_HEAD: </style>

* Overview

  I'm going to keep a diary of my effort to develop a web app from soup to nuts.

  The initial plans are in [[file:README.org][README.org]].

* Java

  Currently running my wiki on JSPWiki on Tomcat 8 on Java 8.  I'd like to run a different process
  on Java whatever-is-the-latest.  (Note: I can't.  See [[#jakarta-java-version-question][the Jakarta/Java version question]].

  Looks like some process has kept Java up to date on my AWS server.  Yay.  Also, apparently,
  openjdk is legal to use.  Yay.

  https://adoptopenjdk.net/index.html has the builds for download.

** On a Mac
   
  On a Mac, the OpenJDK 8 installer puts files in
  =/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home/bin=, but I can't seem to
  symlink them in to =/usr/bin=.

** Java EE

   Well, first off, a /lot/ has happened in the Java world since I left it, around 2005 or so.
   (Pshew, was it really that long ago?  Oy.)

   Java EE has become Jakarta EE, and is now managed by the Eclipse Foundation.  It appears that, as
   of <2020-03-09 Mon>, Java EE 8 is the download (from Oracle), but, in future, I guess we'll be
   getting new versions from https://jakarta.ee/.

*** Question: Does Jakarta EE run on any version of Java >= 8?  Answer: apparently not. :(
    :PROPERTIES:
    :CUSTOM_ID: jakarta-java-version-question
    :END:

    Based on this quote: /"We also have to move the APIs to support JDK 11."/ from this article:
    https://dzone.com/articles/jakarta-ee-8-and-beyond. 

** Editing in emacs

   This might be a lost cause, but if you want to get away from magic tools like IntelliJ, Eclipse,
   Vs Code, ...

   https://www.emacswiki.org/emacs/JavaDevelopmentEnvironment

   https://blog.jmibanez.com/2019/03/31/emacs-as-java-ide-revisited.html

* Tomcat

** On a Mac

   Unzipped Tomcat 9 to =/opt=.

   Created user =tomcat= using Mac "Users and Groups" control panel applet.  Disabled login by
   =tomcat= with the following shell command:

   : sudo chpass -s /usr/bin/false tomcat
   
   chown'd the resulting directory (recursively) to user =tomcat=.

   Created a simple =start-tomcat= (and analogous =stop-tomcat=) script in
   =/opt/apache-tomcat-9.0.31/bin= directory:

   #+BEGIN_SRC shell
     #!/bin/bash

     export CATALINA_HOME=/opt/apache-tomcat-9.0.31

     # export CATALINA_BASE=~/Tomcat/apache-tomcat-9.0

     export JAVA_HOME=/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home

     exec su -m tomcat ${CATALINA_HOME}/bin/catalina.sh start
   #+END_SRC

   Edited =/opt/apache-tomcat-9.0.31/conf/tomcat-users.xml= to add users for manager-gui, admin-gui
   and (separate user) manager-script, admin-script.

   Running on AdoptOpenJDK 11 is as easy as downloading and installing it and changing the above
   =JAVA_HOME= to point to the new JDK.  It seems to run without problem.

   It should also be possible to install it via homebrew, which might then keep it up to date better than a manual
   install process would.

   For homebrew, you'll need to open a "tap" (i.e., add another repository), and then install the "cask" for the jdk you
   want.  See the instructions at the adoptopenjdk.

** On Ubuntu Linux 16.04

   See http://tarheel-nc.s3-website-us-east-1.amazonaws.com/tomcat-9-setup.html.

** Deploy code

   Well, first you have to write some code.  See [[#hello-world][Simplest possible code]].
   
* Database

** Consider an ORM of some sort

   This might require using a "more real" database than Sqlite.  Although it might be fun to try. :)

   https://www.eversql.com/i-followed-hibernate-orm-to-hell-and-came-back-alive-to-tell-about-it/

   https://hackr.io/blog/java-frameworks -- Hibernate's in here, along with a /ton/ of other
   frameworks.  Sounds like a good page to refer back to.

** SQLite
   
*** How much does it scale?

    For a toy app (on a toy server), I don't need much.

    But... it looks like it scales quite well, actually.

    https://blog.expensify.com/2018/01/08/scaling-sqlite-to-4m-qps-on-a-single-server/

    https://stackoverflow.com/a/62220

    https://news.ycombinator.com/item?id=11934826

    https://www.whoishostingthis.com/compare/sqlite/optimize/

** Postgresql

   Well, after all the Sqlite awesomeness, maybe I'll put this bad boy off a while more.  I don't
   really intend to become a d/b geek.

** Apache Derby

   All-java embedded database, but probably not as widely used as Sqlite.  Advantage: probably works
   well with Hibernate and other Java technologies.  Derby seems to perform better.

   As if I care, with my 12-record database.
   
* JavaEE dependencies

  I feel like there's a license restriction on the EE libs from Oracle.  So I need to find an
  implementation I can use.

  Turns out...

  #+BEGIN_QUOTE
  The Apache TomcatÂ® software is an open source implementation of the Java Servlet, JavaServer
  Pages, Java Expression Language and Java WebSocket technologies. The Java Servlet, JavaServer
  Pages, Java Expression Language and Java WebSocket specifications are developed under the Java
  Community Process.
  #+END_QUOTE

  (From https://tomcat.apache.org/, right at the top.)

  This at least satisfies the compiler:

  : javac -cp /opt/apache-tomcat-9.0.31/lib/servlet-api.jar com/how_hard_can_it_be/play/Main.java

  /I think/ you can also add them via Maven (from
  https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api/4.0.1):

  See [[#how-to-make-javax-servlet-dependencies-available][How to make =javax.servlet= dependencies available]], below.

* JS Framework

* Build system

** Gradle
   
   Gradle is not the clean, well-documented system I had hoped for.  Maybe if this turns into a big,
   giant project, it might pay off, but there seems to be a ton black magic documented in example
   code and (probably) StackOverflow answer, so... maybe just use Maven.

** RESEARCH-DONE Maven
   CLOSED: [2020-03-30 Mon 22:06]
   :PROPERTIES:
   :CUSTOM_ID: maven
   :END:

   Back to Maven, until I give up on it again.

   Need to figure out how to download dependencies over https.

   Need to figure out a project structure.  Somewhere between simple-weapp and J2EE-webapp.

*** Install/update
    
   Update maven, configure PATH.  (Is that really all I have to do?)  On a Mac.

   Ok, so, I just downloaded the zip from Apache, unzipped it into =/opt= and symlinked the /three/
   executable files in the =bin= directory to =/usr/local/bin=, which is already on the path.

*** RESEARCH-DONE Make a project
    CLOSED: [2020-03-30 Mon 22:06]

    After much reading of Maven docs (finally), I think something like the J2EE project structure
    (below, but you probably don't need to go read it) is the way to go.  All I ever built in the
    past was a single Maven project, but a project (parent, packaging = =pom=) that has the
    following sub-projects shouldn't be too hard.

    - business logic, with minimal dependencies (onion architecture core)
    - utilities I will probably use in other projects (again, minimal dependencies, and particularly
      no dependencies on UI or d/b layers).  Maybe this is where I'd put interface/facade code for
      common stuff like logging.
    - the actual web stuff, which would probably be a pretty thin layer around the business logic.
      One exception to the "thin layer" concept is that I guess this is where I'd stick all my
      super-fancy javascript UI stuff.  The server would probably concentrate on returning JSON
      responses to RESTful (?) queries.

    Wonder if I can create these as completely independent of each other (i.e., in different
    directories, not subdirectories) and then tie them all together with the parent POM.  See
    https://maven.apache.org/pom.html#Aggregation.  Answer: yes.  (But I'm not doing it right away.)

    Basically: (1) create a parent project (once), cd into the parent project directory, and (2)
    create sub-projects, Archetypes to be used:

    - maven-archetype-quickstart (parent and jar-type subs)
    - maven-archetype-webapp (probably just need one of these)

    #+BEGIN_QUOTE 
    (Note: there might be some scary warnings at the beginning about HTTPS being required, but it works
    ok for setting up the initial project.  In my case, they came from my old =.m2= repository, and
    when I blew it away, the errors cleared up (because new versions got downloaded).)
    #+END_QUOTE 

    Then, change the packaging of the parent project to =pom=, add the subprojects, etc., etc., as
    documented at
    https://maven.apache.org/guides/getting-started/index.html#How_do_I_build_more_than_one_project_at_once.

**** Effective POM

     : mvn help:effective-pom

     Shows super-POM merged w/your POM (or inherited POM hierarchy, if you are so bold).

**** Patching up generated POMs

     Looks like Maven generates POMs that need a little more detail.  (Or sometimes, they have too
     much detail, like for really old JDK versions.)

     I put these property definitions at the end of the "header" section of the POM:

     #+BEGIN_SRC xml
       <properties>
         <maven.compiler.source>11</maven.compiler.source>
         <maven.compiler.target>11</maven.compiler.target>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
       </properties>
     #+END_SRC

**** How to define servlets (where the source code goes)

     Servlet source code goes in web project, in directory
     =src/main/java/<package-directory-structure>/Foo.java=.  Binary winds up in the war file in
     =WEB-INF/classes=.

**** How to make =javax.servlet= dependencies available
     :PROPERTIES:
     :CUSTOM_ID: how-to-make-javax-servlet-dependencies-available
     :END:

     Tomcat 9 provides:

     | *Spec*                 | *Version* |
     | Servlet                |       4.0 |
     | JSP                    |       2.3 |
     | EL                     |       3.0 |
     | WebSocket              |       1.1 |
     | JASIC (authentication) |       1.1 |

     I'm /guessing/ we won't need the JSP and EL specs, since we'll (probably) be emiting JSON, not
     HTML.

     So, we need something like the following:

     #+BEGIN_SRC xml
       <dependency>
         <groupId>javax.servlet</groupId>
         <artifactId>javax.servlet-api</artifactId>
         <version>3.0.1</version>
         <scope>provided</scope>  <!--  "provided" means we need this JAR for a successful compile, but it won't be included in
                                        the generated output, because we expect the container to which the generated WAR is
                                        deployed to provide its own compatible version of the JAR.
                                  -->
       </dependency>
     #+END_SRC

     But the version we need is probably 4.0.x?

     The effective POM has Maven Central at https://repo.maven.apache.org/maven2.  So... from the
     versions listed at https://repo.maven.apache.org/maven2/javax/servlet/javax.servlet-api/, it
     looks like maybe 4.0.1 is the version we want.

     Searching at https://search.maven.org/ with search =g:javax.servlet a:javax.servlet-api= yields
     a hit.  Clicking on the result (try the artifact id or the version count) yields a snippet of
     info, including the GitHub repository and home page.

     And, finally, after all that... we build (=mvn package=), and... voila!  (It got automatically
     downloaded and the compile succeeds, after we updated our tiny class to have a dependency on
     =HttpServlet=.)

     #+BEGIN_EXAMPLE
       deimos$ pwd
       /Users/john/.m2/repository/javax/servlet/javax.servlet-api/4.0.1

       deimos$ lscf
       _remote.repositories                      javax.servlet-api-4.0.1.jar
       javax.servlet-api-4.0.1-javadoc.jar       javax.servlet-api-4.0.1.jar.sha1
       javax.servlet-api-4.0.1-javadoc.jar.sha1  javax.servlet-api-4.0.1.pom
       javax.servlet-api-4.0.1-sources.jar       javax.servlet-api-4.0.1.pom.sha1
       javax.servlet-api-4.0.1-sources.jar.sha1  m2e-lastUpdated.properties
     #+END_EXAMPLE 

     (Whether it runs is something we'll find out later.)

     The next step, I think, is to fix up routing so a url will go to the servlet.  See [[#servlet-routing][Servlet
     Routing]].

**** File structure for "simple J2EE" (ha)
     :PROPERTIES:
     :CUSTOM_ID: j2ee-project-structure
     :END:

     I don't think I need all of the J2EE project stuff, such as the EJBs and the "ear" folder, but
     the rest are probably good.  I guess I could just delete the unwanted directories and remove
     references to them from the ancester POMs.  Then, the final deliverable is the "servlets" (or
     "servlets/servlet") project, packaged as war.

    The project dir root contains the following:

    - pom.xml -- overall POM
    - primary-source -- core/unique business logic
      - pom.xml -- sub-POM for the main source, which is a jar
      - src
        - main
          - java
            - com
              - how_hard_can_it_be.com
                - offtotheraces
        - test
          - java
      - target -- all the magic that Maven does, probably includes the jar generated from primary-source
    - projects -- @@html:<span class="open-question">@@ secondary/reusable source, I guess @@html:</span>@@
      - pom.xml
      - logging -- sample project
        - pom.xml -- each project gets its own POM
        - src
          - main
            - java
          - test
            - java
        - target -- Maven-generated
    - servlets (plural) -- actual JSPs and servlets, which should be thin logic around the business
      logic.  Note also that, buried below here, are the static files for the web app (js, css,
      images, etc.)
      - pom.xml
      - servlet (singular) -- @@html:<span class="open-question">@@ Not sure why there's a singular
        "servlet" directory under the plural "servlets" directory. @@html:</span>@@
        - src
          - main
            - java
            - webapp
              - WEB-INF
                - web.xml
              - index.jsp
              - /(other JSPs and static resources (css, js, images, etc.), presumably/
          - test
            - java
        - target
    - ejbs -- @@html:<span class="open-question">@@ I guess these are also thin layers around
      business logic @@html:</span>@@ 
      - pom.xml
      - src
        - main
          - java
          - resource -- resource bundles for configuration, i18n, similar stuff?
            - META-INF
              - ejb-jar.xml - @@html:<span class="open-question">@@ No idea what this is
                @@html:</span>@@ 
        - test
          - java
      - target
    - ear -- @@html:<span class="open-question">@@ I have no idea what goes in here @@html:</span>@@ 
      - pom.xml
      - src
        - main
          - java
        - test
          - java
      - target

**** Further info on the "simple" J2EE packaging, from reference docs

     https://maven.apache.org/archetypes/maven-archetype-j2ee-simple/index.html

*** Reactor?  What's that?

    Built-in part of Maven that decides in what order to build component modules (sub-projects),
    given their interdependencies.  Not a plug-in; don't sweat it.

* App code

** Simplest possible code
   :PROPERTIES:
   :CUSTOM_ID: hello-world
   :END:

   #+BEGIN_SRC java
     @WebServlet(urlPatterns = { "/hello" })
     public class HelloServlet extends HttpServlet
     {
        public void doGet(HttpServletRequest aRequest, HttpServletResponse aResponse) 
           throws ServletException, IOException
        {
           aRequest.getServletContext().getRequestDispatcher("/index.jsp").forward(aRequest, aResponse);
        }
     }
   #+END_SRC 

** Other aspects to consider
*** Servlet Routing
    :PROPERTIES:
    :CUSTOM_ID: servlet-routing
    :END:

    How to define routings so that URLs map to servlets.

    Servlet mappings.  Chapter 12 of the Servlet 4.0 spec, available at
    https://javaee.github.io/servlet-spec/downloads/servlet-4.0/servlet-4_0_FINAL.pdf.

    Also, use the =WebServlet= annotation to specify mappings at the level of each servlet, so you
    don't have to go edit =web.xml=.

*** JSON output

    Is there an easy way?  Or do I just call =toJson()= on some object and write it to the response
    stream?

    Actually, it looks pretty simple.

    See https://www.baeldung.com/servlet-json-response, but basically, it's:

    #+BEGIN_SRC java
      String employeeJsonString = new Gson().toJson(employee);
      PrintWriter out = response.getWriter();
      response.setContentType("application/json");
      response.setCharacterEncoding("UTF-8");
      out.print(employeeJsonString);
      out.flush();
    #+END_SRC

    /Gson/ is Google's JSON serializer.  /Jackson/ is the more "standard" java-world serializer,
    and, like all things Java-world, it's both more complex and more powerful (I guess).

*** Logging & Telemetry
*** Security & Griefing
*** Documentation generation
*** Automated testing
**** Unit
**** Integration
**** Database?
*** Command pattern, undo/redo trees
*** Well-known APIs
**** Documenting with something like Swagger
*** Data export/import
*** Packaging -- how the entire project is structed

    Maybe... web stuff in the war, but business logic and persistence in other jars?  See [[#maven][Maven]].
