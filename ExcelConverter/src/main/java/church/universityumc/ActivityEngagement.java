package church.universityumc;

import java.util.Calendar;
import java.util.Date;

/**
 * An activity a {@link ChurchMember} may engage in.  If this has associated dates, it's (obviously?) some
 * sort of activity in which a church member has engaged.  If it has no associated dates, it's assumed to be
 * some sort of skill or other background info about the church member.
 *
 */
public class ActivityEngagement
{
   private ActivityType _activityType;
   private Activity     _activity;
   private ActivityRole _role;
   private Date         _startDate, _endDate;
   private boolean      _hasRotationDate;
   
   /**
    * This constructor is intended to build an {@link ActivityEngagement} from fields read directly from the
    * report generated by ACS.  Since the ACS schema is a little wacky, this constructor will have to do some
    * wacky things.  In short, the parameters of this constructor (a) do not correspond 1-to-1 with the data
    * members of this object, and (2) may not be entirely accurate.
    * 
    * @param anActivityType - May include some notion of a start date
    * @param anActivityName
    * @param anActivityRole - The {@link ChurchMember}'s role in the activity
    * @param aStartDate - May be null, in which case an effort will be made to obtain it from anActivityType.
    * @param anEndDate - May be null, or possibly only year or month & year are accurate.
    * @param aHasRotationDateFlag - If false, then the activity explicitly no end date (as opposed to data
    *       simply being missing or unparseable).
    */
   public ActivityEngagement( 
         String anActivityType,
         String anActivityName,
         String anActivityEndYearString,
         String anActivityRole
         )
   {
      _activityType = ActivityType.find( anActivityType);
      _activity = Activity.find( anActivityName);
      _role = ActivityRole.find( anActivityRole);
      
      initStartDate();
      initEndDate( anActivityEndYearString);
      if (_endDate != null && _startDate != null && _endDate.before( _startDate))
         Log.warn( "created ActivityEngagement, but end-date (%tc) < start-date (%tc)", _endDate, _startDate);
   }

   /**
    * Initialize {@link #_startDate} from {@link #_activityType}.
    */
   private void initStartDate()
   {
      if (_activityType.getStartYear() == null)
         _startDate = null;
      else
      {
         Calendar cal = Calendar.getInstance();
         cal.clear();
         cal.set( Calendar.YEAR, _activityType.getStartYear());
         if (_activityType.getStartMonth() != null) cal.set( Calendar.MONTH, _activityType.getStartMonth());
         // Assume day doesn't need to be set because of the .clear() call above.
         _startDate = cal.getTime();
      }
   }

   /**
    * Initialize {@link #_endDate} and {@link #_hasRotationDate} from given end-year string, after {@link #_startDate}
    * has already been set.
    * 
    * @param anActivityEndYearString
    */
   private void initEndDate( String anActivityEndYearString)
   {
      if (anActivityEndYearString == null || anActivityEndYearString.equals( ""))
         ;
      else
      {
         try
         {
            ParsedDate parsedEndDate = new ParsedDate( anActivityEndYearString);
            if (parsedEndDate.explicitNone)
            {
               _hasRotationDate = false;
            }
            else
            {
               _hasRotationDate = true;
               Calendar cal = Calendar.getInstance();
               cal.clear();
               if (parsedEndDate.year == null)
               {
                  Log.warn( "Can't find year in activity end date \"%s\"", anActivityEndYearString);
               }
               else
               {
                  if (parsedEndDate.date == null)
                  {
                     // We don't have a full date, but we do have at least a year.
                     cal.set( Calendar.YEAR, parsedEndDate.year);
                     if (_activityType.getStartMonth() == null 
                           || parsedEndDate.year.equals( _activityType.getStartYear()))
                     {
                        // No start month OR end year == start year (so a month boundary would be meaningless); assume
                        // calendar year boundaries -- last day of current year.
                        cal.set( Calendar.DAY_OF_YEAR, cal.getActualMaximum( Calendar.DAY_OF_YEAR));
                     }
                     else
                     {
                        // Last day of previous month.
                        cal.set( Calendar.MONTH, _activityType.getStartMonth());
                        cal.roll( Calendar.MONTH, false);
                        cal.set( Calendar.DAY_OF_MONTH, cal.getActualMaximum( Calendar.DAY_OF_MONTH));
                     }
                     // End date is last second of last minute of last hour of day.
                     cal.set( Calendar.HOUR_OF_DAY, cal.getActualMaximum( Calendar.HOUR_OF_DAY));
                     cal.set( Calendar.MINUTE, cal.getActualMaximum( Calendar.MINUTE));
                     cal.set( Calendar.SECOND, cal.getActualMaximum( Calendar.SECOND));
                  }
                  else
                     cal.setTime( parsedEndDate.date);
                  _endDate = cal.getTime();
               }
            }
         }
         catch (java.text.ParseException exc)
         {
            StringBuilder msg = new StringBuilder( exc.getMessage());
            Log.warn( msg.toString(), (Object[]) null);
         }
      }
   }

   /**
    * @return the activityType
    */
   public ActivityType getActivityType()
   {
      return _activityType;
   }

   /**
    * @return the activity
    */
   public Activity getActivity()
   {
      return _activity;
   }

   /**
    * @return the role
    */
   public ActivityRole getRole()
   {
      return _role;
   }

   /**
    * @return the startDate
    */
   public Date getStartDate()
   {
      return _startDate;
   }

   /**
    * @return the endDate
    */
   public Date getEndDate()
   {
      return _endDate;
   }

   /**
    * @return the hasRotationDate
    */
   public boolean hasRotationDate()
   {
      return _hasRotationDate;
   }

   /**
    * The skill associated with this {@link ActivityEngagement} (which, in this case, probably IS the
    * description/definition of a skill).
    * 
    * @return may be null
    */
   public Skill toSkill()
   {
      // TODO: escape/encode attributes for XML
      String skillName = String.format( "<skill type=\"%s\" activity=\"%s\" role=\"%s\"/>",
            _activityType.getName(), _activity.getName(), _role.getName());
      Log.warn( "Turning ActivityEngagement into Skill \"%s\", which is probably a Bad Idea", skillName);
      Skill retval = Skill.find( skillName);
      // TODO: source?
      return retval;
   }
   
   public String toString()
   {
      StringBuilder retval = new StringBuilder(
            String.format( "%s (%s), %tD - ", getActivity().getName(), getActivityType().getName(), getStartDate()));
      if (hasRotationDate())
         retval.append( String.format( "%tD", getEndDate()));
      else
         retval.append( "(no end date)");
      retval.append( ")");
      return retval.toString();
   }
}
