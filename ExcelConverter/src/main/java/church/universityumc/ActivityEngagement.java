package church.universityumc;

import java.util.Calendar;
import java.util.Date;

/**
 * An activity a {@link ChurchMember} may engage in.  If this has associated dates, it's (obviously?) some
 * sort of activity in which a church member has engaged.  If it has no associated dates, it's assumed to be
 * some sort of skill or other background info about the church member.
 *
 */
public class ActivityEngagement
{
   private ActivityType activityType;
   private Activity activity;
   private ActivityRole role;
   private Date startDate, endDate;
   private boolean hasRotationDate;
   
   /**
    * Where the data originally came from in the ACS spreadsheet.
    */
   private RowType dataSource;

//   private Logger logger;
   
   /**
    * This constructor is intended to build an {@link ActivityEngagement} from fields read directly from the
    * report generated by ACS.  Since the ACS schema is a little wacky, this constructor will have to do some
    * wacky things.  In short, the parameters of this constructor (a) do not correspond 1-to-1 with the data
    * members of this object, and (2) may not be entirely accurate.
    * 
    * @param anActivityType - May include some notion of a start date
    * @param anActivityName
    * @param anActivityRole - The {@link ChurchMember}'s role in the activity
    * @param aStartDate - May be null, in which case an effort will be made to obtain it from anActivityType.
    * @param anEndDate - May be null, or possibly only year or month & year are accurate.
    * @param aHasRotationDateFlag - If false, then the activity explicitly no end date (as opposed to data
    *       simply being missing or unparseable).
    */
   public ActivityEngagement( 
         // Row aRow
         String anActivityType,
         String anActivityName,
         String anActivityEndYearString,
         String anActivityRole,
         AppLogger anAppLogger
         // Date aStartDate,
         // Date anEndDate,
         // boolean aHasRotationDateFlag
         )
   {
//      logger = System.getLogger( "church.universityumc");

//      Iterator<Cell> iter = aRow.cellIterator();
//
//      String activityTypeString = iter.next().getStringCellValue();
//      String activityName = iter.next().getStringCellValue();
//      String activityEndYearString = iter.next().getStringCellValue();
//      String activityRoleString = iter.next().getStringCellValue();

      activityType = ActivityType.find( anActivityType);
      activity = Activity.find( anActivityName);
      role = ActivityRole.find( anActivityRole);
      
      if (activityType.getStartYear() == null)
         startDate = null;
      else
      {
         Calendar cal = Calendar.getInstance();
         cal.clear();
         cal.set( Calendar.YEAR, activityType.getStartYear());
         if (activityType.getStartMonth() != null) cal.set( Calendar.MONTH, activityType.getStartMonth());
         // Assume day doesn't need to be set because of the .clear() call above.
         startDate = cal.getTime();
      }

      ParsedDate parsedEndDate;

      try
      {
         parsedEndDate = new ParsedDate( anActivityEndYearString);
         if (parsedEndDate.explicitNone)
         {
            hasRotationDate = false;
         }
         else
         {
            hasRotationDate = true;
            Calendar cal = Calendar.getInstance();
            cal.clear();
            if (parsedEndDate.year == null)
            {
               anAppLogger.warn( "Can't find year in activity end date \"%s\"", anActivityEndYearString);
            }
            else
            {
               if (parsedEndDate.date == null)
               {
                  cal.set( Calendar.YEAR, parsedEndDate.year);
                  if (activityType.getStartMonth() == null)
                  {
                     // No start month; assume calendar year boundaries -- last day of current year.
                     cal.set( Calendar.DAY_OF_YEAR, cal.getActualMaximum( Calendar.DAY_OF_YEAR));
                  }
                  else
                  {
                     // Last day of previous month.
                     cal.set( Calendar.MONTH, activityType.getStartMonth());
                     cal.roll( Calendar.MONTH, false);
                     cal.set( Calendar.DAY_OF_MONTH, cal.getActualMaximum( Calendar.DAY_OF_MONTH));
                  }
               }
               else
                  cal.setTime( parsedEndDate.date);
               endDate = cal.getTime();
            }
         }
      }
      catch (java.text.ParseException exc)
      {
         StringBuilder msg = new StringBuilder( exc.getMessage());
         anAppLogger.warn( msg.toString(), (Object[]) null);
      }
   }

   /**
    * @return the activityType
    */
   public ActivityType getActivityType()
   {
      return activityType;
   }

   /**
    * @return the activity
    */
   public Activity getActivity()
   {
      return activity;
   }

   /**
    * @return the role
    */
   public ActivityRole getRole()
   {
      return role;
   }

   /**
    * @return the startDate
    */
   public Date getStartDate()
   {
      return startDate;
   }

   /**
    * @return the endDate
    */
   public Date getEndDate()
   {
      return endDate;
   }

   /**
    * @return the hasRotationDate
    */
   public boolean hasRotationDate()
   {
      return hasRotationDate;
   }

   /**
    * The skill associated with this {@link ActivityEngagement} (which, in this case, probably IS the
    * description/definition of a skill).
    * 
    * @return may be null
    */
   public Skill toSkill()
   {
      // TODO Auto-generated method stub
      return null;
   }
   
   
}
