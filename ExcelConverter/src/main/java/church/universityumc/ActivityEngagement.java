package church.universityumc;

import java.io.StringWriter;
import java.util.Calendar;
import java.util.Date;

import javax.xml.bind.JAXBException;

import church.universityumc.excelconverter.App;

/**
 * An activity a {@link ChurchMember} may engage in.  If this has associated dates, it's (obviously?) some
 * sort of activity in which a church member has engaged.  If it has no associated dates, it's assumed to be
 * some sort of skill or other background info about the church member.
 *
 */
public class ActivityEngagement
{
   private ActivityType activityType;
   private Activity     activity;
   private ActivityRole role;
   private Date         startDate, endDate;
   private boolean      hasRotationDate;
   
   /**
    * This constructor is intended to build an {@link ActivityEngagement} from fields read directly from the
    * report generated by ACS.  Since the ACS schema is a little wacky, this constructor will have to do some
    * wacky things.  In short, the parameters of this constructor (a) do not correspond 1-to-1 with the data
    * members of this object, and (2) may not be entirely accurate.
    * 
    * @param anActivityType - May include some notion of a start date
    * @param anActivityName
    * @param anActivityRole - The {@link ChurchMember}'s role in the activity
    * @param aStartDate - May be null, in which case an effort will be made to obtain it from anActivityType.
    * @param anEndDate - May be null, or possibly only year or month & year are accurate.
    * @param aHasRotationDateFlag - If false, then the activity explicitly no end date (as opposed to data
    *       simply being missing or unparseable).
    */
   public ActivityEngagement( 
         String anActivityType,
         String anActivityName,
         String anActivityEndYearString,
         String anActivityRole
         )
   {
      activityType = ActivityType.find( anActivityType);
      activity = Activity.find( anActivityName);
      role = ActivityRole.find( anActivityRole);
      
      initStartDate();
      initEndDate( anActivityEndYearString);
      if (endDate != null && startDate != null && endDate.before( startDate))
         Log.warn( "created ActivityEngagement, but end-date (%tc) < start-date (%tc)", endDate, startDate);
   }

   public ActivityEngagement( 
         String anActivityType, 
         String anActivityName, 
         String anActivityStartDate,
         String anActivityEndDate, 
         String anActivityRole)
   {
      activityType = ActivityType.find( anActivityType, anActivityStartDate);
      activity = Activity.find( anActivityName);
      role = ActivityRole.find( anActivityRole);

      initStartDate();
      initEndDate( anActivityEndDate);
      if (endDate != null && startDate != null && endDate.before( startDate))
         Log.warn( "created ActivityEngagement, but end-date (%tc) < start-date (%tc)", endDate, startDate);
   }

   /**
    * Initialize {@link #startDate} from {@link #activityType}.
    */
   private void initStartDate()
   {
      if (activityType.getStartYear() == null)
         startDate = null;
      else
      {
         Calendar cal = Calendar.getInstance();
         cal.clear();
         cal.set( Calendar.YEAR, activityType.getStartYear());
         if (activityType.getStartMonth() != null) cal.set( Calendar.MONTH, activityType.getStartMonth());
         // Assume day doesn't need to be set because of the .clear() call above.
         startDate = cal.getTime();
      }
   }

   /**
    * Initialize {@link #endDate} and {@link #hasRotationDate} from given end-year string, after {@link #startDate}
    * has already been set.
    * 
    * @param anActivityEndYearString
    */
   private void initEndDate( String anActivityEndYearString)
   {
      if (anActivityEndYearString == null || anActivityEndYearString.equals( ""))
         ;
      else
      {
         try
         {
            ParsedDate parsedEndDate = new ParsedDate( anActivityEndYearString);
            if (parsedEndDate.explicitNone)
            {
               hasRotationDate = false;
            }
            else
            {
               hasRotationDate = true;
               Calendar cal = Calendar.getInstance();
               cal.clear();
               if (parsedEndDate.year == null)
               {
                  Log.warn( "Can't find year in activity end date \"%s\"", anActivityEndYearString);
               }
               else
               {
                  if (parsedEndDate.date == null)
                  {
                     // We don't have a full date, but we do have at least a year.
                     cal.set( Calendar.YEAR, parsedEndDate.year);
                     if (activityType.getStartMonth() == null 
                           || parsedEndDate.year.equals( activityType.getStartYear()))
                     {
                        // No start month OR end year == start year (so a month boundary would be meaningless); assume
                        // calendar year boundaries -- last day of current year.
                        cal.set( Calendar.DAY_OF_YEAR, cal.getActualMaximum( Calendar.DAY_OF_YEAR));
                     }
                     else
                     {
                        // Last day of previous month.
                        cal.set( Calendar.MONTH, activityType.getStartMonth());
                        cal.roll( Calendar.MONTH, false);
                        cal.set( Calendar.DAY_OF_MONTH, cal.getActualMaximum( Calendar.DAY_OF_MONTH));
                     }
                     // End date is last second of last minute of last hour of day.
                     cal.set( Calendar.HOUR_OF_DAY, cal.getActualMaximum( Calendar.HOUR_OF_DAY));
                     cal.set( Calendar.MINUTE, cal.getActualMaximum( Calendar.MINUTE));
                     cal.set( Calendar.SECOND, cal.getActualMaximum( Calendar.SECOND));
                  }
                  else
                     cal.setTime( parsedEndDate.date);
                  endDate = cal.getTime();
               }
            }
         }
         catch (java.text.ParseException exc)
         {
            StringBuilder msg = new StringBuilder( exc.getMessage());
            Log.warn( msg.toString(), (Object[]) null);
         }
      }
   }

   /**
    * @return the activityType
    */
   public ActivityType getActivityType()
   {
      return activityType;
   }

   /**
    * @return the activity
    */
   public Activity getActivity()
   {
      return activity;
   }

   /**
    * @return the role
    */
   public ActivityRole getRole()
   {
      return role;
   }

   /**
    * @return the startDate
    */
   public Date getStartDate()
   {
      return startDate;
   }

   /**
    * @return the endDate
    */
   public Date getEndDate()
   {
      return endDate;
   }

   /**
    * @return the hasRotationDate
    */
   public boolean hasRotationDate()
   {
      return hasRotationDate;
   }

   /**
    * The skill associated with this {@link ActivityEngagement} (which, in this case, probably IS the
    * description/definition of a skill).
    * 
    * @return may be null
    * @throws JAXBException 
    */
   public Skill toSkill() throws JAXBException
   {
      InferredSkill iskill = new InferredSkill( activityType.getName(), activity.getName(), role.getName());
      StringWriter sw = new StringWriter();
      App.inferredSkillMarshaller.marshal( iskill, sw);
      String skillName = sw.toString();
      Log.warn( "Turning ActivityEngagement into Skill \"%s\", which is probably a Bad Idea", skillName);
      Skill retval = Skill.find( skillName, InfoSource.UndatedEngagement);
      return retval;
   }
   
   public String toString()
   {
      StringBuilder retval = new StringBuilder(
            String.format( "%s (%s), %tD - ", getActivity().getName(), getActivityType().getName(), getStartDate()));
      if (hasRotationDate())
         retval.append( String.format( "%tD", getEndDate()));
      else
         retval.append( "(no end date)");
      retval.append( ")");
      return retval.toString();
   }
}
