#+TITLE: Convert AccessACS Excel Output to a More Usable Format
* Overview

  The problem is that AccessACS (our church info system) spits out reports in Excel format that are
  (sort of) readable by humans, but not very useful for computers.  For example, we get a church
  member's name in one row, then a bunch of prior activities in the following rows.  Ideally, we'd
  get all that in one monster row or even separate linked tables.

  This utility will handle the conversion from AccessACS's output to a more useful form for us.

* Roadmap

  (Note: See the various project boards, including the one for the Excel converter at
  [[https://github.com/JohnL4/LayLeadership/projects/1][https://github.com/JohnL4/LayLeadership/projects/1]].)

  GitHub doesn't format org-mode files very well (I'm glad it handles org-mode at all, though), so here's the short
  version:

  - [X] [[*Setup -- get the technology running, prove things are possible][Setup -- get the technology running, prove things are possible]]
  - [X] [[*Read & Parse Excel generated from an ACS report][Read & Parse Excel generated from an ACS report]]
    - [X] Basic member info
    - [X] Activities
    - [X] Skills
    - [X] Comments
  - [X] [[*Write out new spreadsheet in more-usable format][Write out new spreadsheet in more-usable format]]
    - [X] Probably requires going back over the internal d/b to make sure everything is shipshape
      - [X] Activity
      - [X] Skill
      - [X] ActivityRole
      - [X] ActivityType
    - [X] Actually write out spreadsheet, tab per table, probably
  - [ ] [[*Update external SQL database][Update external SQL database]]
  - [ ] [[*Web app to maintain data in SQL database][Web app to maintain data in SQL database]]

** DONE Setup -- get the technology running, prove things are possible
   CLOSED: [2018-01-28 Sun 13:04]

   - CLOSING NOTE [2018-02-12 Mon 13:04] \\
     Well, as done as it'll ever be.

*** Java

    Well-developed, publicly-available language allowing non-hacky development that I'm most familiar with, and that
    other developers are most likely to be familiar with (I know everybody knows PHP or Ruby or Python, but I think Java
    is really the most straightforward and is pretty widely known).  Has good libraries for Excel spreadsheet, SQL
    database, web API access.  All of that edges out other possibilities, in my mind:

    - Python :: Good language, but I'm not as familiar with it as I am with Java.
    - Node.js :: I'm a big fan of strong, static typing, and I see Javascript as really a little too "cowboy".
    - C# :: Microsoft.  In spite of MS's recent "MS (loves) Linux" horsefeathers, I still don't like them.  In the long
            run, something more open and accorded first-class citizenship on more platforms (Apple, Linux) is going to
            be better, I believe.  Microsoft has too much history with licensing and other legal tricks for me to really
            trust something like Mono.
    - Perl :: Good language, but I was ready to move on 15 years ago.  Besides, line noise ain't my thing.
    - Go, Rust, D :: All wonderful languages, I have no doubt, but (a) intended for low-level system programming, and
                     (b) what kind of Excel-spreadsheet-readin' libraries do they have?
    - C, C++ :: These languages are the reason Java exists.  Similar arguments as for Go, Rust, and D.
    - PHP :: No.  Just no.  No language for which /<Language> the Right Way/ is required reading is a good idea.

*** Maven

    Dependency-management and build system.  Great for sharing dependencies with other developers and automating testing
    (if I bother to write any unit tests, which I may actually do, at some point) and building.

*** RESEARCH-HOLD Amazon Web Services (AWS)
    CLOSED: [2018-01-31 Wed 13:21]

    - State "RESEARCH-HOLD" from "RESEARCH-IN-PROGRESS" [2018-02-12 Mon 13:21] \\
      Did some initial research, but now I'm mostly coding the spreadsheet-reading software.
    If we take the route of having data on a central server somewhere (as opposed to somebody's individual PC), I
    nominate AWS as the most stable and cheapest solution.  This is something I'm currently researching, 

** DONE Read & Parse Excel generated from an ACS report
   CLOSED: [2018-02-19 Mon 00:17]
   - CLOSING NOTE [2018-02-19 Mon 00:17]
*** DONE Basic church member info
    CLOSED: [2018-02-07 Wed 13:13]

    - CLOSING NOTE [2018-02-12 Mon 13:13] \\
      Pending issues I discover while running the whole shebang for real.
    Name, phone, etc.

*** DONE Member activities
    CLOSED: [2018-02-19 Mon 00:15]
    - CLOSING NOTE [2018-02-19 Mon 00:15]
    Past and present committees, skills survey data, etc.

*** DONE Member comments
    CLOSED: [2018-02-19 Mon 00:15]
    - CLOSING NOTE [2018-02-19 Mon 00:15]
    As far as I can tell right now, this is only general biographical info, from the member's initial introduction to
    the church during the "new member" moments.

** TODO Write out new spreadsheet in more-usable format

   Allow searching and filtering and maybe sorting.

** TODO Update external SQL database

   PostreSQL, in this case.  I propose to use AWS RDS (https://aws.amazon.com/rds/).

   Another possibility is simply a local database instance, either Postgres or maybe even ~sqlite~.

** TODO Web app to maintain data in SQL database

   This is more of a long shot, and I'm not 100% sure we'll even do it.  But if we are going to have an external system,
   this is /probably/ the best way to go.
   
   I propose to use the Amazon Serverless Application Model (RDS, Lambda, Cognito, API Gateway).

* Expected input

  This program expects input in the form of a spreadsheet with a layout matching the sample input
  distributed with it.

* Build, Run

** Copy Dependencies

  (Really, only needs to be done the first time or when you change dependencies)

  : mvn dependency:copy-dependencies

** Test

  : mvn test

** Build

   (Also runs unit tests)

  : mvn package

  Output goes to ~target~ directory, and you can run it from, for testing (or from your IDE, whatever).

  : mvn package assembly:single

  Should generate a zip file with all dependencies, so you can distribute just that zip.  User unzips and runs main jar
  with the command given below.

  TODO: might need to do something similar with a source distributable (? maybe?) so the mvn ~release~ plugin will do
  the right thing.

** Run

  : java -Djava.util.logging.config.file=logging.properties -jar <jarFileName> [options]

  Note the -D logging config option gives problems in PowerShell.  You can leave it out, but the logging will only use
  default config.

*** To actually convert spreadsheets

    1. Make sure you have at least the Java Runtime Environment (JRE) installed.  You can get it at
       https://java.com.  (Don't worry if your browser doesn't run it; modern browsers don't run any
       plugins by default, as a security measure.)

    2. Go to a shell window ("command prompt" on Windows) and type the following at the command
       prompt:
    
    #+BEGIN_SRC bash
    java -jar /path/to/excel-converter-1.0-SNAPSHOT.jar -f "original input.xlsx" --xlsx "reformatted output.xlsx"
    #+END_SRC

    If you're on Windows, use backslashes (\) instead of forward slashes.
    
* Logger Format

** How to activate

   Logging properties are in the file ~logging.properties~.

   Specify as ~-Djava.util.logging.config.file=./logging.properties~ (or whatever the path to your logging config file
   is) option to ~java~ command (on the command line) /before/ the ~-jar excel-converter-1.0-SNAPSHOT.jar~ part.

*** TODO Add this logging.properties file to pom.xml to make sure it winds up in the ~target~ output directory

** Technical details
   
  ~String.format()~ call with the following arguments:

  | *1*  | *2*    | *3*    | *4*   | *5*     | *6*    |
  | date | source | logger | level | message | thrown |

  Format looks a lot like the old ~printf(3)~ C call:
  
  : [%1$tF %1$tT.%1$tL %3$s %4$-7s] %5$s%n

  ~n$~ refers to the n-th argument to ~format()~.

  ~tF~ formats dates as Y-m-d.

  ~tT~ formats dates (times) as H:M:S.

  ~tL~ formats millisecond parts of times as 999 (with leading zeros).

  ~n~ is a newline character (line terminator for whatever the current platform is)
  
* XML

  XML schema definition ~vocationalSkill.xsd~ generated with ~schemagen~ tool included in JDK 9.

  In future releases of the JDK (10, 11, ...) this tool will probably be removed (as will the ~javax.xml.bind~ package
  and, possibly, associated packages).  Read the ~pom.xml~ for tips on recovering a reference to those libraries.

